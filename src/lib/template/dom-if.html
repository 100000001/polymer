<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="templatizer.html">

<script>

  /**
   * Stamps the template iff the `if` property is truthy.
   *
   * When `if` becomes falsey, the stamped content is hidden but not
   * removed from dom. When `if` subsequently becomes truthy again, the content
   * is simply re-shown. This approach is used due to its favorable performance
   * characteristics: the expense of creating template content is paid only
   * once and lazily.
   *
   * Set the `restamp` property to true to force the stamped content to be
   * created / destroyed when the `if` condition changes.
   */
  Polymer({

    is: 'dom-if',
    extends: 'template',
    _template: null,

    /**
     * Fired whenever DOM is added or removed/hidden by this template (by
     * default, rendering occurs lazily).  To force immediate rendering, call
     * `render`.
     *
     * @event dom-change
     */

    properties: {

      /**
       * A boolean indicating whether this template should stamp.
       */
      'if': {
        type: Boolean,
        observer: '_queueRender'
      },

      /**
       * When true, elements will be removed from DOM and discarded when `if`
       * becomes false and re-created and added back to the DOM when `if`
       * becomes true.  By default, stamped elements will be hidden but left
       * in the DOM when `if` becomes false, which is generally results
       * in better performance.
       */
      restamp: {
        type: Boolean
      },

      __hideTemplateChildren__: {
        observer: '_showHideChildren'
      }

    },

    _queueRender: function() {
      Polymer.Templatizer._debounceTemplate.call(this, this._render);
    },

    created: function() {
      this._nodes = [];
    },

    detached: function() {
      // TODO(kschaaf): add logic to re-stamp in attached?
      this._teardownChildren();
    },

    attached: function() {
      if (this.if && this.ctor) {
        // TODO(sorvell): should not be async, but node can be attached
        // when shady dom is in the act of distributing/composing so push it out
        this.async(this._ensureChildren);
      }
    },

    /**
     * Forces the element to render its content. Normally rendering is
     * asynchronous to a provoking change. This is done for efficiency so
     * that multiple changes trigger only a single render. The render method
     * should be called if, for example, template rendering is required to
     * validate application state.
     */
    render: function() {
      Polymer.Templatizer._flushTemplates.call(this);
    },

    _render: function() {
      if (this.if) {
        if (!this._setupComplete) {
          this._setup();
        }
        this._ensureChildren();
        this._showHideChildren();
      } else if (this.restamp) {
        this._teardownChildren();
      }
      if (!this.restamp && this._children) {
        this._showHideChildren();
      }
      if (this.if != this._lastIf) {
        this.fire('dom-change');
        this._lastIf = this.if;
      }
    },

    _setup: function() {
      this._template = this;
      this._content = this._content || this.content;
      if (this._content._setup) {
        this.mixin(this, this._content._setup);
      } else {
        this._prepAnnotations();
        this._addPropertyEffect = function(model, type, effect) {
          if (type == 'annotation') {
            effect.value = '_parent_' + effect.value;
            model = '_parent_' + model;
            var fx = this._propertyEffects[model];
            if (!fx) {
              this._addPropertyEffect(model, 'notify', {
                event: Polymer.CaseMap.camelToDashCase(model) + '-changed'});
            }
          }
          Polymer.Base._addPropertyEffect.call(this, model, type, effect);
        };
        this._addAnnotatedListener = function(index, name, value, event) {
          Polymer.Base._addAnnotatedListener.call(this, index, name, '_parent_' + value, event);
        };
        this._propertyEffects = Object.create(this._propertyEffects);
        this._propertyInfo = Object.create(this._propertyInfo);
        this._addAnnotationEffects(this._notes);
        this._content._setup = {
          _propertyEffects: this._propertyEffects,
          _propertyInfo: this._propertyInfo,
          _bindListeners: this._bindListeners,
          _notes: this._content._notes
        };
      }
      var props = this._content._parentProps;
      for (var p in props) {
        p = '_parent_' + p;
        var val = this[p];
        if (val !== undefined) {
          this.__data__[p] = val;
        }
      }
      this._setupComplete = true;
    },

    _ensureChildren: function() {
      if (!this._children) {
        this._clientsReadied = false;
        this._clients = [];
        this._beginHosting();
        this._template = this;
        this._stampTemplate();
        // this.parentNode.insertBefore(this.root, this);
        this._endHosting();
        this._marshalAnnotatedNodes();
        if (this._bindListeners) {
          Polymer.Bind.setupBindListeners(this);
        }
        this._rootDataHost = Polymer.Templatizer._getRootDataHost.call(this);
        this._marshalAnnotatedListeners(this._rootDataHost);
        this._children = [];
        var root = this.root;
        root.__noContent = !(this._content._notes && this._content._notes._hasContent);
        root.__styleScoped = true;
        for (var el=root.firstChild; el; el=el.nextSibling) {
          this._children.push(el);
        }
        var parentNode = Polymer.dom(this).parentNode;
        if (parentNode) {
          var parent = Polymer.dom(parentNode);
          parent.insertBefore(root, this);
        }
        this._configureAnnotationReferences();
        this._distributeConfig(this.__data__);
        this._readyClients();
        this._clientsReadied = true;
        this._flushHandlers();
      }
    },

    _teardownChildren: function() {
      if (this._children) {
        var c$ = this._children;
        // use first child parent, for case when dom-if may have been detached
        var parent = Polymer.dom(Polymer.dom(c$[0]).parentNode);
        for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {
          parent.removeChild(n);
        }
        this._nodes = [];
        this._children = null;
      }
    },

    _showHideChildren: function() {
      if (this._children) {
        var hidden = this.__hideTemplateChildren__ || !this.if;
        Polymer.Templatizer._showHideChildrenImpl.call(this, hidden);
      }
    }

  });

</script>
